# 스프링 핵심 원리 - 고급편
## ThreadLocal
쓰레드 로컬은 해당 쓰레드만 접근할 수 있는 특별한 저장소를 말한다.
쓰레드A와 쓰레드B의 데이터를 각각 저장하고 쓰레드에 따라 저장한 데이터를 구별해준다.
쓰레드 로컬을 사용하면 동시성 문제를 해결할 수 있다.
```java
// ThreadLocal<T> 변수명 = new ThreadLocal<>();
ThreadLocal<String> userName = new ThreadLocal<>();

// 데이터 set
userName.set("홍길동");

// 데이터 get
userName.get();

// 쓰레드 로컬 제거
userName.remove();
```
쓰레드 로컬은 사용후 ``remove()``를 호출해서 제거해주어야 한다.
다 사용한 뒤에 제거를 해주지 않으면 메모리 누수가 발생 할 수 있다.
***
## TemplateMethod Pattern
> 작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기합니다. 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있습니다.
> -GoF-

부모 클래스에 알고리즘의 골격인 템플릿을 정의하고, 일부 변경되는 로직은 자식 클래스에 정의하는 것이다.
이렇게 하면 자식 클래스가 알고리즘의 전체 구조를 변경하지 않고, 특정 부분만 재정의할 수 있다. 상속과 오버라이딩을 통한
다형성으로 문제를 해결하는 것이다.

"하지만"

상속을 사용하기 때문에 상속의 단점을 그대로 안고간다. 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제가 있다.
자식 클래스의 입장에서는 부모 클래스의 기능을 사용하지 않지만 템플릿 메서드 패턴을 구현하기 위해 부모 클래스를 상속받는다.
부모 클래스에 새로운 메서드가 추가 되면 모든 자식 클래스들은 사용하지 않아도 새로 추가된 메서드를 오버라이딩 해야 한다.
***
## Strategy Pattern
> 알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만들자. 전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.
> -GoF-
> 
변하지 않는 부분을 `context`라는 곳에 두고, 변하는 부분을 `strategy`라는 인터페이스를 만들고
각각의 전략들은 `strategy`인터페이스를 구현하도록해 문제를 해결한다. 템플릿 메서드 패턴과 다르게 상속이 아니라 위임으로 문제를 해결한다.

전략 패턴은 2가지로 나눌 수 있다.
1. `context`와 `strategy`를 조립후 실행하는 방법
2. `context`를 실행 할 때 `strategy`를 전달 받아 실행하는 방법이 있다.

1의 경우는 이미 조립이 끝났기 떄문에 전략을 신경쓰지 않고 실행에 초점을 둔다 하지만 전략을 변경하는데 유연하지 않다.
2의 경우 실행직전 전략을 받아 실행하기 때문에 전략을 변경하기 매우 쉽지만 실행할 때 마다 전략을 지정해주어야 한다.
***
## Proxy
클라이언트는 서버에 필요한 것을 요청하고, 서버는 클라이언트의 요청을 처리한다.
이 개념을 객체에 도입하면 요청하는 객체는 클라이언트, 요청을 처리하는 객체는 서버가 된다.

일반적으로 클라이언트가 서버에게 요청을 하고 처리 결과를 직접 받는다. 이것을 직접호출이라고 한다.
클라이언트가 서버에게 직접 요청을 하는것이 아니라 어떤 대리자를 통해 간접적으로 서버에게 요청을 할 수 있다.
여기서 대리자를 Proxy라고 한다.

Proxy는 클라이언트의 요청뿐만 접근제어, 캐싱, 부가 기능추가등 다양한 동작을 할 수 있고
클라언트는 요청이후의 과정에 대해서는 알필요가 없다.

### Proxy의 역할
> 대체 가능

객체에서 프록시가 되려면, 클라이언트는 서버에게 요청을 한 것인지 프록시에게 요청한 것인지 조차 몰라야 한다.
서버와 클라이언트는 같은 인터페이스를 사용해야 한다.
클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.

> 접근 제어

권한에 따른 접근 허용/차단, 캐싱, 지연로딩

> 부가 기능 추가

원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다.

예)
* 요청값이나 응답 값을 중간에 변형
* 실행시간 측정
***
## Reflection
리플렉션 기술을 사용하면, 클래스나 메서드의 메타정보를 동적으로 획득하고, 동적으로 호출 할 수 있다.
***
## JDK 동적 프록시
동적 프록시 기술을 사용하면 개발자가 직접 프록시 클래스를 만들지 않아도 된다.(런타임에 개발자 대신 만들어준다.)
> 주의 <br>
> JDK 동적 프록시는 인터페이스를 기반으로 프록시를 동적으로 만들어준다. 따라서 인터페이스가 필수이다.
***
## CGLIB
CGLIB는 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리이다. 인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들어낼 수 있다.
CGLIB는 원래는 외부 라이브러리인데, 스프링 프레임워크가 스프링 내부 소스 코드에 포함했다.
> CGLIB 제약<br>
> * 클래스 기반 프록시는 상속을 사용을 사용하기 때문에 몇가지 제약이 있다.
>   * 부모 클래스의 생성자를 체크해야 한다. -> CGLIB는 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요하다.
>   * 클래스에 `final`키워드가 붙으면 상속이 불가능하다. -> CGLIB에서는 예외가 발생한다.
>   * 메서드에 `final`키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다. -> CGLIB에서는 프록시 로직이 동작하지 않는다.
***
## Proxy Factory
프록시 팩토리를 활용 하면 인터페이스가 있는 경우는 JDK 동적 프록시를, 그렇지 않으면 CGLIB를 적용할 수 있다.

### Advice
``Advice``는 프록시에 적용하는 부가 기능 로직이다. 이것은 JDK 동적 프록시가 제공하는
``InvocationHandler`` 와 CGLIB가 제공하는 ``MethodInterceptor`` 의 개념과 유사한다. 둘을 개념적으로
추상화 한 것이다. 프록시 팩토리를 사용하면 둘 대신에 ``Advice``를 사용하면 된다.
***
## PointCut, Advice, Advisor
> PointCut <br>
어디에 부가 기능을 적용 할지, 어디에 부가 기능을 적용하지 않을지 판단하는 필터링 로직

> Advice <br>
프록시가 호출하는 부가 기능

> Advisor <br>
단순하게 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 것이다. 쉽게
이야기해서 포인트컷1 + 어드바이스1이다.

### 역할과 책임
이렇게 구분한 것은 역할과 책임을 명확하게 분리한 것이다.
포인트컷은 대상 여부를 확인하는 필터 역할만 담당한다.
어드바이스는 깔끔하게 부가 기능 로직만 담당한다.
둘을 합치면 어드바이저가 된다. 스프링의 어드바이저는 하나의 포인트컷 + 하나의 어드바이스로 구성된다.
***
## Bean PostProcessor
스프링이 Bean 저장소에 등록할 목적으로 생성한 객체를 Bean 저장소에 등록하기 직전에 조작하고 싶다면 Bean 후처리기를 사용하면 된다.
이름 그대로 Bean을 생성한 후에 무언가를 처리하는 용도로 사용한다.

### Bean 등록 과정과 후처리기
1. **생성**: 스프링 Bean 대상이 되는 객체를 생성한다.(`@Bean`, 컴포넌트 스캔 모두 포함)
2. **전달**: 생성된 객체를 Bean 저장소에 등록하기 직전에 Bean 후처리기에 전달한다.
3. **후 처리 작업**: Bean 후처리기는 전달된 스프링 Bean 객체를 조작하거나 다른 객체로 교체할 수 있다.
4. **등록**: Bean 후처리기는 Bean을 반환한다. 전달된 Bean을 그대로 반환하면 해당 Bean이 등록되고, 교체하면 교체한 객체를 Bean 저장소에 등록한다.
***
## @Aspect
스프링은 `@Aspect`애노테이션으로 편리하게 포인트컷과 어드바이스로 구성된 어드바이저 생성기능을 제공한다.

* `@Aspect`: 애노테이션 기반 프록시를 적용할 때 필요하다.
* `@Around("execution(* hello.proxy.app..(..))")`
  * `@Around`의 값에 포인트컷 표현식을 넣는다. 표현식은 `AspectJ`표현식을 사용한다.
  * `@Around`의 메서드는 어드바이스(`Advice`)가 된다.
* `ProceedingJointPointcut`: 어드바이스에서 살펴본 `MethodInvocation invocation`과 유사한 기능이다. 내부에서 실제 호출될 대상, 전달 인자, 그리고 어떤 객체와 어떤 메서드가 호출되었는지 정보가 포함되어있다.
* `joinPoint.proceed()`: 실제 호출 대상(target)을 호출한다.

### @Aspect를 어드바이저로 변환해서 저장하는 과정
1. **실행**: 스프링 애플리케이션 로딩 시점에 자동 프록시 생성기를 호출한다.
2. **모든 `@Aspect` 빈 조회**: 자동 프록시 생성기는 스프링 컨테이너에서 `@Aspect` 애노테이션이 붙은 스프링 빈을 모두 조회한다.
3. **어드바이저 생성**: `@Aspect`어드바이저 빌더를 통해 `@Aspect`애노테이션 정보를 기반으로 어드바이저를 생성한다.
4. **`@Aspect`기반 어드바이저 저장**: 생성한 어드바이저를 `@Aspect` 어드바이저 빌더 내부에 저장한다.

### @Aspect 어드바이저 빌더
`BeanFactoryAspectJAdvisorBuiler`클래스이다. `@Aspect`의 정보를 기반으로 포인트컷, 어드바이스, 어드바이저를 생성하고 보관하는 것을 담당한다.
`@Aspect`의 정보를 기반으로 어드바이저를 만들고 @Aspect어드바이저 빌더 내부 저장소에 캐시한다. 캐시에 어드바이저가 이미 만들어져 있는 경우 캐시된 어드바이저를 반환한다.

